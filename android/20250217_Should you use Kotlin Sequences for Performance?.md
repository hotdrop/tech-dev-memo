# Should you use Kotlin Sequences for Performance?
- Android Dagashi 2/16
- https://androiddagashi.github.io/issue/364-2025-02-16/

# 要約
Kotlinの`Collection`, `Sequence`, `Flow`の違いを踏まえ、`Sequence`が中間コレクションを作らずにパフォーマンス向上に寄与するのではという仮説で検証している。

- `Collection`では、例えば`filter`のような高階関数を使うと毎回新しいコレクションが生成されるため、途中で余計な中間コレクション（ガベージ）が生まれてしまう
- 一方、`Sequence`は遅延評価によって中間コレクションを作らずに処理を連鎖させるので、メモリ使用量が削減できるはずという仮説が立てられている。

## ベンチマークからの結果考察
3つの実装に対して`kotlinx-benchmark`を使用して実施。
1. List版: 単純にリスト上で`filter`とmapを使っている。
2. Sequence版: リストをシーケンスに変換してから同じ操作を実施し、最後にリストに戻している。
3. Flow版: 非現実的な例としてFlowを使っているが、同じく変換処理を行い最後にリストに変換。

**結果**
- シンプルなチェーン操作では、`Sequence`より`List`の方が約9%高速。
- 複雑な処理（複数の中間操作がある場合）では、`List`に比べ`Sequence`が45%も遅くなる場合がある。
- 驚くべきことに`Flow`は一部のケースで`List`や`Sequence`を上回るパフォーマンスを示した。

**得られた結果からの教訓**
- `Sequence`は単純な操作では必ずしもパフォーマンス改善につながらず、むしろオーバーヘッドが問題になる
- `Flow`は非同期処理向けであり、いくつかのケースでは最適化が働いているが、本来の用途とは異なる
- 通常の変換操作では`Collections`（もしくは場合によっては`ImmutableArray`）の利用が最も効率的
- 著者自身もコードレビューで`asSequence`を推奨していたが、結果を受けて見直す必要があると感じた。

# コメント
コメント欄も面白かった。概ねこのベンチマークに同意しているような印象だった。

- Sequenceは内部でIteratorを使っているため、フィールドのコピーやhasNext/nextの呼び出しが頻発しこれがCPUオーバーヘッドにつながるとの指摘がある。そのため、単純な連鎖処理では遅延評価のメリットが相殺される可能性がある。
  - このオーバーヘッドの問題を解決するためPushベースのFlowモデルが提案されており、操作をまとめることにより効率化が期待できるとされる。
- 極端な例でAndroidのベンチマークライブラリを使った場合、メモリ使用量の削減効果はあまり顕著ではなかったとされ、現実のシナリオではListのメモリ負荷はごく小さいという意見もある。
- モバイルアプリでは通常、データ件数は約100件程度であり巨大なリストを扱う状況は少ない。そのためListのメモリ使用量は問題になりにくいと指摘されている。
- Listのサイズが変わるとパフォーマンスの比較結果も変動するのではと疑問を呈しており、大規模データにおける検証も重要とされている。
- 連続したフラットなメモリ（Array）の操作が非常に高速であり、逃避解析などの最適化が働く可能性を示唆している
- Sequenceはメモリ負荷の高い計算や早期終了が可能なシナリオでは効果を発揮する場合もあるが、小規模データやモバイルアプリではむしろオーバーヘッドが目立つと述べられている。
- 異なる操作の連鎖でならメリットが出るはずだと期待していたが、実際には単純な連鎖ではパフォーマンス改善が得られないと感じたとコメントしている。